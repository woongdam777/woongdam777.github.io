---
title: 브라우저 렌더링 과정
author: w
date: 2024-01-26 19:53:00 +0800
categories: [CS 지식 쌓기, 웹]
tags: [question, resolve]
---

## 브라우저 렌더링?

크롬에다가 www.naver.com 사이트 주소를 입력하는 시점부터 네이버 화면이 나오기까지<br>
크롬이 작동하는 과정을 렌더링이라고 이해하면 간단합니다.

1. 사용자가 브라우저에 사이트 주소를 입력
2. 주소에 있는 서버가 약속되어 있는 html파일을 우리 브라우저로 전송
3. 전송받는 html코드는 8bit 데이터 형테로 전송됨 = 바이트 스트림
4. 전송받으면 일단 텍스트로 변환
5. DOM tree / CSSOM tree 생성
6. DOM tree / CSSOM tree 합쳐서 render tree 생성
7. 레이아웃 트리 생성
8. 페인트
9. composite

참고한 문서
https://developer.chrome.com/blog/inside-browser-part3?hl=ko

참고한 유튜브 영상
https://www.youtube.com/watch?v=v8H5ujL4Tt8 [10분 테코톡] 결의 브라우저 렌더링
https://www.youtube.com/watch?v=z1Jj7Xg-TkU 브라우저는 어떻게 화면을 렌더링할까?(프론트엔드 개발 지망생이라면 필수 시청!!)

### 토큰
토큰과 비교해서 html코드인지 확인


HTML 파싱 및 DOM 트리 생성

HTML 파일을 받아서 바이트 스트림으로 변환 후 문자로 해석하여 HTML 코드인지 확인
토큰을 통해 HTML 코드를 확인하고 노드를 생성하여 DOM 트리 구축
DOM 트리는 HTML의 구조를 반영하며 노드로 이루어진 거대한 구조

CSS 파싱 및 CSSOM 트리 생성
CSS 파일을 받아 문자로 해석하여 CSS 객체 모델(CSSOM) 생성
CSSOM은 CSS 속성 정보를 담은 트리 구조

레이아웃 단계(Layout)
DOM 트리와 CSSOM 트리를 결합하여 렌더 트리(Render Tree) 생성
렌더 트리는 화면에 실제로 표시되는 요소들을 포함한 트리 구조
요소의 크기, 좌표 등의 정보를 담은 레이아웃 트리(Layout Tree) 생성

페인트 단계(Paint)
렌더 트리를 기반으로 요소들을 화면에 그리는 작업 수행
텍스트, 이미지, 보더, 그림자 등 시각적 요소를 그리는 과정

컴포지팅 단계(Composite)
페인트된 요소들을 스크린에 픽셀로 표현하여 페이지를 완성하는 과정
여러 레이어를 합성하여 최종 화면을 구성

리플로우와 리페인트
CSS 속성 변경 등으로 레이아웃이 변경되면 리플로우와 리페인트 과정이 발생
리플로우는 레이아웃의 재계산, 리페인트는 화면의 재그리기를 의미
트랜스폼과 오퍼시티 속성은 리플로우와 리페인트를 최소화할 수 있는 속성으로 강조됨


의문점들

렌더링될때 토큰을 통해서 노드를 생성하잖아? 그러면 생성하는 위치가 어디에 생성이되? 

브라우저가 HTML 코드를 파싱하고 렌더링할 때 토큰을 통해 노드를 생성하는 위치는 DOM(Document Object Model)
DOM은 문서의 구조화된 표현이며, HTML 문서를 트리 구조로 나타내어 웹 페이지의 내용을 프로그래밍적으로 조작하고 제어할 수 있도록 합니다.
HTML 코드의 각 요소들은 DOM의 노드로 변환됩니다. 예를 들어, HTML의 div, p, span 등의 요소들은 각각 DOM의 요소 노드(Element Node)로 변환됩니다. 또한, 텍스트 노드(Text Node)도 생성되어 HTML의 텍스트 내용을 DOM에 반영합니다.
따라서 HTML 코드를 파싱하는 과정에서 생성된 각 토큰은 해당하는 DOM 노드로 변환되어 DOM 트리에 삽입됩니다. 이렇게 생성된 DOM 트리는 웹 페이지의 구조를 나타내며, 이를 통해 JavaScript 등의 스크립트 언어를 사용하여 웹 페이지의 동적인 요소를 조작할 수 있습니다.

생성될때 script를 만나면 렌더링이 중단되?
네, 맞습니다. 브라우저가 HTML을 렌더링하는 과정에서 script
태그를 만나면 일반적으로 렌더링이 중단됩니다. 이러한 동작은 브라우저가 HTML을 파싱하고 렌더링하는 동안 스크립트를 실행하기 위한 것입니다.

브라우저가 script
태그를 만나면 해당 스크립트를 가져와 해석하고 실행해야 합니다. 스크립트가 다른 리소스를 로드하거나 실행에 시간이 오래 걸릴 수도 있기 때문에, 이 과정에서 렌더링이 중단됩니다. 스크립트의 실행이 끝나야 다시 렌더링을 진행할 수 있습니다.
이러한 이유로 스크립트를 페이지의 끝 부분에 배치하는 것이 권장되는 이유 중 하나입니다. 페이지의 렌더링을 중단시키지 않고 먼저 페이지의 구조와 콘텐츠를 사용자에게 표시한 후에 스크립트를 실행하여 사용자 경험을 향상시킬 수 있습니다.

js에서 fetch나 axio?같은 비동기 요소를 만나면 그요소가 끝나지 않아도 html렌더링이 진행되나?

네, JavaScript에서 fetch나 Axios와 같은 비동기 요소를 만나더라도 HTML 렌더링은 진행됩니다. 이러한 비동기 요소는 브라우저의 이벤트 루프를 통해 백그라운드에서 처리되며, HTML을 파싱하고 렌더링하는 동안에도 병행적으로 실행됩니다.
브라우저는 HTML을 파싱하고 렌더링하는 도중에 JavaScript 코드를 만나면 해당 코드를 해석하고 실행하기 시작합니다. 만약 JavaScript 코드가 비동기 요청을 포함한다면, 이 요청은 백그라운드에서 처리됩니다. 브라우저는 이러한 비동기 요청이 완료될 때까지 기다리지 않고 다음 단계로 진행합니다.
따라서 HTML의 파싱 및 렌더링이 중단되지 않고 계속 진행되며, 비동기 요청의 응답이 도착하면 해당 이벤트에 대한 콜백 함수가 실행되어 처리됩니다. 이것이 JavaScript의 비동기 처리의 핵심적인 특성 중 하나이며, 웹 애플리케이션에서 더 나은 사용자 경험을 제공하는 데 도움이 됩니다.

저런요소가 없다면 js가 끝나기 전까진 렌더링이 중단되겠네?

네, 맞습니다. JavaScript 코드가 실행 중이고 해당 코드가 동기적인 작업을 수행하는 경우, 브라우저는 JavaScript 코드의 실행이 완료될 때까지 HTML 렌더링을 중단합니다. 이것은 JavaScript의 동기적 특성 때문에 발생하는 현상입니다.
따라서 JavaScript 코드가 HTML 파싱 및 렌더링 중에 실행되고 있고, 그 코드가 비동기 요소를 사용하지 않는다면, JavaScript 코드의 실행이 완료될 때까지 브라우저는 HTML 파싱과 렌더링을 중단합니다. 이는 일반적으로 브라우저의 단일 스레드 모델로 인해 발생합니다.
따라서 웹 개발에서는 JavaScript 코드를 효율적으로 작성하고 비동기적인 패턴을 활용하여 브라우저의 렌더링을 중단시키지 않도록 하는 것이 중요합니다. 비동기적인 작업을 수행하고 필요한 경우 콜백 함수나 프로미스를 사용하여 작업이 완료될 때까지 기다리지 않고도 다른 작업을 계속할 수 있도록 해야 합니다.


그러면 돔트리는 html렌더링이 끝나야 생성이 완료되는거네? 그럼 css는?

네, DOM 트리는 HTML 파싱 및 렌더링이 완료된 후에 생성됩니다. HTML 문서가 파싱되고 각 요소들이 DOM 노드로 변환되면, 이러한 노드들이 모여서 트리 구조를 형성하게 됩니다. 이것이 DOM 트리입니다. 따라서 HTML 문서의 파싱이 완료되어야만 DOM 트리가 완전히 생성됩니다.
CSS는 HTML 문서의 파싱과는 별개로 처리됩니다. HTML 문서가 파싱되는 동안에도 CSS는 병렬적으로 로드되고 파싱됩니다. CSS 파일이 다운로드되고 파싱되면, CSS 규칙은 스타일 정보를 담은 CSS 객체 모델(CSSOM)로 변환됩니다.
DOM 트리와 CSSOM이 모두 준비되면, 이 두 가지를 결합하여 렌더 트리(Render Tree)가 생성됩니다. 렌더 트리는 화면에 실제로 표시되는 요소들로 이루어진 트리 구조입니다. 이 과정에서 CSS 규칙이 HTML 요소에 적용되어 렌더링될 요소들이 결정됩니다.
따라서 HTML 파싱과 CSS 로드 및 파싱이 완료되면 브라우저는 DOM 트리와 CSSOM을 결합하여 렌더 트리를 생성하고, 이를 기반으로 화면에 요소들을 배치하고 스타일을 적용합니다. 이후에 렌더링이 진행됩니다.

병렬적이라고 하면 동시에 시작되?
네, "병렬적"이라는 용어는 일반적으로 동시에 시작되고 동시에 처리되는 것을 나타냅니다. 그러나 웹 브라우저에서 HTML 문서와 CSS 파일을 병렬적으로 처리하는 것은 조금 다를 수 있습니다.
HTML 문서의 파싱은 일반적으로 순차적으로 진행됩니다. 즉, HTML 문서는 위에서부터 아래로 파싱되며, 각 요소가 순서대로 처리됩니다. 그러나 브라우저는 HTML 문서를 파싱하는 동안 CSS 파일의 로드와 파싱을 병렬적으로 진행합니다. 이는 브라우저가 네트워크에서 CSS 파일을 요청하고 받아오는 동안 HTML 문서의 파싱을 멈추지 않고 진행할 수 있도록 하기 위한 것입니다.
따라서 CSS 파일이 HTML 파싱과 병렬적으로 로드되고 파싱되며, 이 과정에서 브라우저는 다른 리소스를 요청하거나 처리하는 동안에도 HTML 문서의 파싱을 계속할 수 있습니다. 이렇게 함으로써 페이지의 렌더링 속도를 향상시킬 수 있습니다.

html하고 css가 동시에 시작되고 둘다 완료된 부분이 있다면 합쳐져?

HTML과 CSS는 동시에 시작되지만, 각각의 파싱 및 처리 과정은 서로 독립적으로 진행됩니다. HTML과 CSS는 서로 다른 파일이기 때문에 각각의 파싱 및 처리는 독립적으로 이루어집니다.
HTML 문서는 순차적으로 파싱되며, HTML 파싱이 완료되면 DOM 트리가 생성됩니다. CSS 파일은 병렬적으로 로드되고, CSS 파싱이 완료되면 CSSOM( CSS Object Model)이 생성됩니다.
이후, DOM 트리와 CSSOM이 모두 준비되면 이 둘을 결합하여 렌더 트리(Render Tree)가 생성됩니다. 렌더 트리는 화면에 실제로 표시되는 요소들로 이루어진 트리 구조입니다. 이 과정에서 CSS 규칙이 HTML 요소에 적용되어 렌더링될 요소들이 결정됩니다.
따라서 HTML과 CSS의 처리 과정은 동시에 시작되지만, 각각의 처리가 완료된 후에야 그 결과가 결합되어 화면에 렌더링되는 것입니다.

둘다 끝나야 끝난 결과를 가지고 그걸 합친다는거지?

네, 맞습니다. HTML과 CSS의 처리 과정은 독립적으로 이루어지지만, 둘 다 처리가 완료된 후에 그 결과가 합쳐져서 화면에 렌더링됩니다.
HTML 문서는 파싱되어 DOM 트리로 변환되고, CSS 파일은 로드되어 파싱되어 CSSOM으로 변환됩니다. 이후에는 DOM 트리와 CSSOM이 모두 준비되면 렌더 트리로 합쳐지게 됩니다. 이 과정에서 HTML 요소와 CSS 규칙이 결합되어 실제로 화면에 표시될 요소들이 결정됩니다.
렌더 트리가 생성되면, 브라우저는 이를 기반으로 레이아웃을 계산하고 화면에 요소들을 배치하여 최종적인 화면을 사용자에게 보여줍니다. 이 과정에서 HTML과 CSS의 처리 결과가 함께 사용되어 화면이 완성됩니다.

렌더 트리가 생성되고 레이아웃 트리가 생성되잖아 

네, 맞습니다. 렌더 트리(Render Tree)가 생성된 후에는 레이아웃 트리(Layout Tree)가 생성됩니다.
렌더 트리는 화면에 표시되는 요소들로 이루어진 트리 구조입니다. 이 트리에는 HTML 요소와 해당 요소에 적용된 CSS 스타일이 반영됩니다.
렌더 트리가 생성되면, 브라우저는 각 요소의 크기, 위치 등을 계산하여 레이아웃 트리를 생성합니다. 레이아웃 트리는 화면에 요소들이 배치되는 실제 레이아웃을 나타내는 트리입니다.
레이아웃 트리가 생성되면, 브라우저는 화면에 요소들을 배치하고 렌더링을 진행합니다. 이 과정에서 요소들의 크기와 위치가 결정되며, 최종적으로 화면에 사용자에게 표시됩니다.
요약하면, 렌더 트리는 HTML 요소와 CSS 스타일을 결합한 구조이고, 레이아웃 트리는 화면에 실제로 요소들이 배치되는 구조를 나타냅니다. 이 두 트리가 함께 작동하여 브라우저가 화면을 렌더링하는 데 필요한 정보를 제공합니다.