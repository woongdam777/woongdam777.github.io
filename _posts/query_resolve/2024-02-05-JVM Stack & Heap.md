---
title: JVM Stack & Heap
author: w
date: 2024-02-03 18:52:00 +0800
categories: [CS 지식 쌓기, 기초]
tags: [question, resolve]
---

## JVM Stack & Heap에 대한 이해
Java Virtual Machine (JVM)의 Stack과 Heap은 Java 프로그램의 메모리 관리를 담당하는 중요한 요소입니다. 이 두 영역은 프로그램 실행 중에 데이터를 저장하고 관리하여 프로그램의 안정성과 성능에 영향을 미칩니다.

### JVM Stack
JVM Stack은 각 스레드마다 별도로 생성되며, 메소드 호출 및 지역 변수를 저장하는데 사용됩니다. 각 메소드 호출 시마다 스택 프레임이 생성되고 메소드가 호출됩니다. 메소드가 종료되면 해당 스택 프레임이 제거됩니다.

스택은 후입선출(LIFO) 구조로 데이터를 저장하며, 재귀 호출 및 메소드 호출에 따른 스택 프레임의 생성 및 제거가 반복됩니다. 스택 프레임에는 메소드의 매개변수, 지역 변수, 메소드의 수행 결과 등이 저장됩니다.

스택 오버플로우(Stack Overflow)는 스택의 용량을 초과하여 발생하는 오류로, 너무 많은 메소드 호출이 재귀적으로 일어날 때 발생할 수 있습니다.

### JVM Heap
JVM Heap은 Java 프로그램이 동적으로 생성하는 객체들을 저장하는 메모리 영역입니다. 모든 객체는 힙에 생성되며, 객체의 크기는 런타임에 결정됩니다. 힙은 Young 영역과 Old 영역으로 나뉘며, 각각 Eden, Survivor, Tenured 영역으로 구성됩니다.

### Eden 영역: 새로 생성된 객체들이 할당되는 곳입니다. Eden 영역이 가득 차면 Minor GC가 발생하여 살아남은 객체들이 Survivor 영역으로 이동합니다.
Survivor 영역: Eden 영역에서 살아남은 객체들이 복사되는 곳입니다. Minor GC 후에는 객체의 생존 여부에 따라 객체가 이동합니다.
Tenured 영역: Old 영역의 일부로, 오래된 객체들이 저장되는 곳입니다. Major GC(또는 Full GC)가 주기적으로 발생하여 메모리를 정리합니다.
힙 메모리 관리는 가비지 컬렉터(Garbage Collector)가 담당하며, 더 이상 참조되지 않는 객체들을 수거하여 메모리를 회수합니다.

### 바이트 코드와 타겟 플랫폼
자바는 플랫폼에 독립적인 언어로, 한 번의 컴파일로 생성된 바이트 코드는 어떤 플랫폼에서든 실행될 수 있습니다. 이는 JVM이 바이트 코드를 해당 플랫폼에 맞게 해석하여 실행하기 때문입니다. 따라서 자바 프로그램은 다양한 플랫폼에서 동작할 수 있습니다.

그러나 C나 C++와 같은 언어는 타겟 플랫폼에 따라 컴파일 과정에서 생성되는 실행 파일이 달라집니다. 따라서 C나 C++ 프로그램은 각 플랫폼에 맞게 컴파일해야 올바르게 동작합니다.

## JVM Stack & Heap의 역할 및 구조
JVM Stack과 Heap은 Java 프로그램의 메모리 관리를 담당합니다. 각각의 역할과 구조를 살펴보면 다음과 같습니다.

### JVM Stack
각 스레드마다 별도의 스택을 가집니다.
메소드 호출 시마다 스택 프레임이 생성되고, 메소드가 종료되면 해당 스택 프레임이 제거됩니다.
메소드 호출, 매개변수, 지역 변수 등을 저장합니다.
스택 오버플로우(Stack Overflow)를 방지하기 위해 제한된 용량을 가집니다.

### JVM Heap
Java 프로그램이 생성하는 객체들을 저장합니다.
Young 영역과 Old 영역으로 나뉘며, 각각 Eden, Survivor, Tenured 영역으로 구성됩니다.
가비지 컬렉터가 더 이상 참조되지 않는 객체를 수거하여 메모리를 회수합니다.
Minor GC와 Major GC(또는 Full GC)가 발생하여 메모리를 정리합니다.
효율적인 메모리 관리를 위해 JVM Stack과 Heap은 각각의 역할과 구조를 가지고 있으며, Java 프로그램의 안정성과 성능에 중요한 영향을 미칩니다.